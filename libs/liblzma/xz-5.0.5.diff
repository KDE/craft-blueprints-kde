diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/common/tuklib_integer.h xz-5.0.5/src/common/tuklib_integer.h
--- xz-5.0.5.orig/src/common/tuklib_integer.h	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/common/tuklib_integer.h	2016-08-25 14:01:05.315093900 +0300
@@ -359,6 +359,9 @@
 
 #endif
 
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+#include <intrin.h>
+#endif
 
 static inline uint32_t
 bsr32(uint32_t n)
@@ -383,7 +386,7 @@
 	// MSVC isn't supported by tuklib, but since this code exists,
 	// it doesn't hurt to have it here anyway.
 	uint32_t i;
-	_BitScanReverse((DWORD *)&i, n);
+    _BitScanReverse(&i, n);
 	return i;
 
 #else
@@ -435,7 +438,7 @@
 
 #elif defined(_MSC_VER) && _MSC_VER >= 1400
 	uint32_t i;
-	_BitScanReverse((DWORD *)&i, n);
+    _BitScanReverse(&i, n);
 	return i ^ 31U;
 
 #else
@@ -485,7 +488,7 @@
 
 #elif defined(_MSC_VER) && _MSC_VER >= 1400
 	uint32_t i;
-	_BitScanForward((DWORD *)&i, n);
+    _BitScanForward(&i, n);
 	return i;
 
 #else
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/check/check.c xz-5.0.5/src/liblzma/check/check.c
--- xz-5.0.5.orig/src/liblzma/check/check.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/check/check.c	2016-08-25 13:59:23.777942400 +0300
@@ -16,9 +16,6 @@
 extern LZMA_API(lzma_bool)
 lzma_check_is_supported(lzma_check type)
 {
-	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)
-		return false;
-
 	static const lzma_bool available_checks[LZMA_CHECK_ID_MAX + 1] = {
 		true,   // LZMA_CHECK_NONE
 
@@ -56,6 +53,9 @@
 		false,  // Reserved
 	};
 
+	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)
+	    return false;
+
 	return available_checks[(unsigned int)(type)];
 }
 
@@ -63,9 +63,6 @@
 extern LZMA_API(uint32_t)
 lzma_check_size(lzma_check type)
 {
-	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)
-		return UINT32_MAX;
-
 	// See file-format.txt section 2.1.1.2.
 	static const uint8_t check_sizes[LZMA_CHECK_ID_MAX + 1] = {
 		0,
@@ -75,7 +72,8 @@
 		32, 32, 32,
 		64, 64, 64
 	};
-
+	if ((unsigned int)(type) > LZMA_CHECK_ID_MAX)
+	    return UINT32_MAX;
 	return check_sizes[(unsigned int)(type)];
 }
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/check/sha256.c xz-5.0.5/src/liblzma/check/sha256.c
--- xz-5.0.5.orig/src/liblzma/check/sha256.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/check/sha256.c	2016-08-25 13:59:23.778918100 +0300
@@ -80,7 +80,13 @@
 
 
 static void
+#ifndef _MSC_VER
+// uint32_t state[static 8] means at least 8 elements
 transform(uint32_t state[static 8], const uint32_t data[static 16])
+#else
+transform(uint32_t state[], const uint32_t data[])
+
+#endif
 {
 	uint32_t W[16];
 	uint32_t T[8];
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/alone_decoder.c xz-5.0.5/src/liblzma/common/alone_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/alone_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/alone_decoder.c	2016-08-25 13:59:23.778918100 +0300
@@ -126,9 +126,7 @@
 	// Fall through
 
 	case SEQ_CODER_INIT: {
-		if (coder->memusage > coder->memlimit)
-			return LZMA_MEMLIMIT_ERROR;
-
+		lzma_ret ret;
 		lzma_filter_info filters[2] = {
 			{
 				.init = &lzma_lzma_decoder_init,
@@ -138,7 +136,11 @@
 			}
 		};
 
-		const lzma_ret ret = lzma_next_filter_init(&coder->next,
+		if (coder->memusage > coder->memlimit)
+			return LZMA_MEMLIMIT_ERROR;
+
+
+		ret = lzma_next_filter_init(&coder->next,
 				allocator, filters);
 		if (ret != LZMA_OK)
 			return ret;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/alone_encoder.c xz-5.0.5/src/liblzma/common/alone_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/alone_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/alone_encoder.c	2016-08-25 13:59:23.779896000 +0300
@@ -78,6 +78,8 @@
 alone_encoder_init(lzma_next_coder *next, lzma_allocator *allocator,
 		const lzma_options_lzma *options)
 {
+	uint32_t d;
+
 	lzma_next_coder_init(&alone_encoder_init, next, allocator);
 
 	if (next->coder == NULL) {
@@ -107,7 +109,7 @@
 	// one is the next unless it is UINT32_MAX. While the header would
 	// allow any 32-bit integer, we do this to keep the decoder of liblzma
 	// accepting the resulting files.
-	uint32_t d = options->dict_size - 1;
+	d = options->dict_size - 1;
 	d |= d >> 2;
 	d |= d >> 3;
 	d |= d >> 4;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/block_buffer_decoder.c xz-5.0.5/src/liblzma/common/block_buffer_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/block_buffer_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/block_buffer_decoder.c	2016-08-25 13:59:23.780874800 +0300
@@ -18,6 +18,9 @@
 		const uint8_t *in, size_t *in_pos, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 {
+        lzma_next_coder block_decoder;
+        lzma_ret ret;
+
 	if (in_pos == NULL || (in == NULL && *in_pos != in_size)
 			|| *in_pos > in_size || out_pos == NULL
 			|| (out == NULL && *out_pos != out_size)
@@ -25,8 +28,8 @@
 		return LZMA_PROG_ERROR;
 
 	// Initialize the Block decoder.
-	lzma_next_coder block_decoder = LZMA_NEXT_CODER_INIT;
-	lzma_ret ret = lzma_block_decoder_init(
+	block_decoder = LZMA_NEXT_CODER_INIT;
+	ret = lzma_block_decoder_init(
 			&block_decoder, allocator, block);
 
 	if (ret == LZMA_OK) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/block_buffer_encoder.c xz-5.0.5/src/liblzma/common/block_buffer_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/block_buffer_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/block_buffer_encoder.c	2016-08-25 13:59:23.781849600 +0300
@@ -31,6 +31,7 @@
 static lzma_vli
 lzma2_bound(lzma_vli uncompressed_size)
 {
+    lzma_vli overhead;
 	// Prevent integer overflow in overhead calculation.
 	if (uncompressed_size > COMPRESSED_SIZE_MAX)
 		return 0;
@@ -39,7 +40,7 @@
 	// uncompressed_size up to the next multiple of LZMA2_CHUNK_MAX,
 	// multiply by the size of per-chunk header, and add one byte for
 	// the end marker.
-	const lzma_vli overhead = ((uncompressed_size + LZMA2_CHUNK_MAX - 1)
+	overhead = ((uncompressed_size + LZMA2_CHUNK_MAX - 1)
 				/ LZMA2_CHUNK_MAX)
 			* LZMA2_HEADER_UNCOMPRESSED + 1;
 
@@ -164,6 +165,9 @@
 		const uint8_t *in, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 {
+    lzma_next_coder raw_encoder = LZMA_NEXT_CODER_INIT;
+    lzma_ret ret;
+    size_t out_start;
 	// Find out the size of the Block Header.
 	block->compressed_size = lzma2_bound(in_size);
 	if (block->compressed_size == 0)
@@ -176,7 +180,7 @@
 	if (out_size - *out_pos <= block->header_size)
 		return LZMA_BUF_ERROR;
 
-	const size_t out_start = *out_pos;
+	out_start = *out_pos;
 	*out_pos += block->header_size;
 
 	// Limit out_size so that we stop encoding if the output would grow
@@ -186,8 +190,7 @@
 
 	// TODO: In many common cases this could be optimized to use
 	// significantly less memory.
-	lzma_next_coder raw_encoder = LZMA_NEXT_CODER_INIT;
-	lzma_ret ret = lzma_raw_encoder_init(
+	ret = lzma_raw_encoder_init(
 			&raw_encoder, allocator, block->filters);
 
 	if (ret == LZMA_OK) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/block_header_decoder.c xz-5.0.5/src/liblzma/common/block_header_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/block_header_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/block_header_decoder.c	2016-08-25 13:59:23.781849600 +0300
@@ -34,6 +34,9 @@
 lzma_block_header_decode(lzma_block *block,
 		lzma_allocator *allocator, const uint8_t *in)
 {
+    size_t in_pos = 2;
+    size_t in_size;
+
 	// NOTE: We consider the header to be corrupt not only when the
 	// CRC32 doesn't match, but also when variable-length integers
 	// are invalid or over 63 bits, or if the header is too small
@@ -56,7 +59,7 @@
 		return LZMA_PROG_ERROR;
 
 	// Exclude the CRC32 field.
-	const size_t in_size = block->header_size - 4;
+	in_size = block->header_size - 4;
 
 	// Verify CRC32
 	if (lzma_crc32(in, in_size, 0) != unaligned_read32le(in + in_size))
@@ -67,7 +70,6 @@
 		return LZMA_OPTIONS_ERROR;
 
 	// Start after the Block Header Size and Block Flags fields.
-	size_t in_pos = 2;
 
 	// Compressed Size
 	if (in[1] & 0x40) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/block_header_encoder.c xz-5.0.5/src/liblzma/common/block_header_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/block_header_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/block_header_encoder.c	2016-08-25 13:59:23.782826000 +0300
@@ -13,16 +13,17 @@
 #include "common.h"
 #include "check.h"
 
-
 extern LZMA_API(lzma_ret)
 lzma_block_header_size(lzma_block *block)
 {
-	if (block->version != 0)
-		return LZMA_OPTIONS_ERROR;
 
 	// Block Header Size + Block Flags + CRC32.
 	uint32_t size = 1 + 1 + 4;
 
+	if (block->version != 0)
+		return LZMA_OPTIONS_ERROR;
+
+
 	// Compressed Size
 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {
 		const uint32_t add = lzma_vli_size(block->compressed_size);
@@ -46,11 +47,12 @@
 		return LZMA_PROG_ERROR;
 
 	for (size_t i = 0; block->filters[i].id != LZMA_VLI_UNKNOWN; ++i) {
+                uint32_t add;
+
 		// Don't allow too many filters.
 		if (i == LZMA_FILTERS_MAX)
 			return LZMA_PROG_ERROR;
 
-		uint32_t add;
 		return_if_error(lzma_filter_flags_size(&add,
 				block->filters + i));
 
@@ -73,20 +75,23 @@
 extern LZMA_API(lzma_ret)
 lzma_block_header_encode(const lzma_block *block, uint8_t *out)
 {
+    size_t out_size;
+    size_t filter_count = 0;
+    size_t out_pos = 2;
+
 	// Validate everything but filters.
 	if (lzma_block_unpadded_size(block) == 0
 			|| !lzma_vli_is_valid(block->uncompressed_size))
 		return LZMA_PROG_ERROR;
 
 	// Indicate the size of the buffer _excluding_ the CRC32 field.
-	const size_t out_size = block->header_size - 4;
+	out_size = block->header_size - 4;
 
 	// Store the Block Header Size.
 	out[0] = out_size / 4;
 
 	// We write Block Flags in pieces.
 	out[1] = 0x00;
-	size_t out_pos = 2;
 
 	// Compressed Size
 	if (block->compressed_size != LZMA_VLI_UNKNOWN) {
@@ -108,7 +113,6 @@
 	if (block->filters == NULL || block->filters[0].id == LZMA_VLI_UNKNOWN)
 		return LZMA_PROG_ERROR;
 
-	size_t filter_count = 0;
 	do {
 		// There can be a maximum of four filters.
 		if (filter_count == LZMA_FILTERS_MAX)
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/block_util.c xz-5.0.5/src/liblzma/common/block_util.c
--- xz-5.0.5.orig/src/liblzma/common/block_util.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/block_util.c	2016-08-25 13:59:23.783802900 +0300
@@ -17,11 +17,14 @@
 extern LZMA_API(lzma_ret)
 lzma_block_compressed_size(lzma_block *block, lzma_vli unpadded_size)
 {
+        lzma_vli compressed_size;
+	uint32_t container_size;
+
 	// Validate everything but Uncompressed Size and filters.
 	if (lzma_block_unpadded_size(block) == 0)
 		return LZMA_PROG_ERROR;
 
-	const uint32_t container_size = block->header_size
+	container_size = block->header_size
 			+ lzma_check_size(block->check);
 
 	// Validate that Compressed Size will be greater than zero.
@@ -31,7 +34,7 @@
 	// Calculate what Compressed Size is supposed to be.
 	// If Compressed Size was present in Block Header,
 	// compare that the new value matches it.
-	const lzma_vli compressed_size = unpadded_size - container_size;
+	compressed_size = unpadded_size - container_size;
 	if (block->compressed_size != LZMA_VLI_UNKNOWN
 			&& block->compressed_size != compressed_size)
 		return LZMA_DATA_ERROR;
@@ -45,6 +48,8 @@
 extern LZMA_API(lzma_vli)
 lzma_block_unpadded_size(const lzma_block *block)
 {
+
+    lzma_vli unpadded_size;
 	// Validate the values that we are interested in i.e. all but
 	// Uncompressed Size and the filters.
 	//
@@ -66,7 +71,7 @@
 		return LZMA_VLI_UNKNOWN;
 
 	// Calculate Unpadded Size and validate it.
-	const lzma_vli unpadded_size = block->compressed_size
+	unpadded_size = block->compressed_size
 				+ block->header_size
 				+ lzma_check_size(block->check);
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/filter_common.c xz-5.0.5/src/liblzma/common/filter_common.c
--- xz-5.0.5.orig/src/liblzma/common/filter_common.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/filter_common.c	2016-08-25 13:59:23.784780200 +0300
@@ -125,11 +125,12 @@
 lzma_filters_copy(const lzma_filter *src, lzma_filter *dest,
 		lzma_allocator *allocator)
 {
+    lzma_ret ret;
+    size_t i;
 	if (src == NULL || dest == NULL)
 		return LZMA_PROG_ERROR;
 
-	lzma_ret ret;
-	size_t i;
+
 	for (i = 0; src[i].id != LZMA_VLI_UNKNOWN; ++i) {
 		// There must be a maximum of four filters plus
 		// the array terminator.
@@ -193,14 +194,14 @@
 static lzma_ret
 validate_chain(const lzma_filter *filters, size_t *count)
 {
-	// There must be at least one filter.
-	if (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)
-		return LZMA_PROG_ERROR;
-
 	// Number of non-last filters that may change the size of the data
 	// significantly (that is, more than 1-2 % or so).
 	size_t changes_size_count = 0;
 
+	// There must be at least one filter.
+	if (filters == NULL || filters[0].id == LZMA_VLI_UNKNOWN)
+		return LZMA_PROG_ERROR;
+
 	// True if it is OK to add a new filter after the current filter.
 	bool non_last_ok = true;
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/filter_encoder.c xz-5.0.5/src/liblzma/common/filter_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/filter_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/filter_encoder.c	2016-08-25 13:59:23.784780200 +0300
@@ -171,6 +171,9 @@
 extern LZMA_API(lzma_ret)
 lzma_filters_update(lzma_stream *strm, const lzma_filter *filters)
 {
+	size_t count = 1;
+	lzma_filter reversed_filters[LZMA_FILTERS_MAX + 1];
+
 	if (strm->internal->next.update == NULL)
 		return LZMA_PROG_ERROR;
 
@@ -180,11 +183,10 @@
 
 	// The actual filter chain in the encoder is reversed. Some things
 	// still want the normal order chain, so we provide both.
-	size_t count = 1;
 	while (filters[count].id != LZMA_VLI_UNKNOWN)
 		++count;
 
-	lzma_filter reversed_filters[LZMA_FILTERS_MAX + 1];
+	
 	for (size_t i = 0; i < count; ++i)
 		reversed_filters[count - i - 1] = filters[i];
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/filter_flags_decoder.c xz-5.0.5/src/liblzma/common/filter_flags_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/filter_flags_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/filter_flags_decoder.c	2016-08-25 13:59:23.785757700 +0300
@@ -18,6 +18,9 @@
 		lzma_filter *filter, lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size)
 {
+    lzma_ret ret;
+    lzma_vli props_size;
+    
 	// Set the pointer to NULL so the caller can always safely free it.
 	filter->options = NULL;
 
@@ -29,7 +32,6 @@
 		return LZMA_DATA_ERROR;
 
 	// Size of Properties
-	lzma_vli props_size;
 	return_if_error(lzma_vli_decode(&props_size, NULL,
 			in, in_pos, in_size));
 
@@ -37,7 +39,7 @@
 	if (in_size - *in_pos < props_size)
 		return LZMA_DATA_ERROR;
 
-	const lzma_ret ret = lzma_properties_decode(
+	ret = lzma_properties_decode(
 			filter, allocator, in + *in_pos, props_size);
 
 	*in_pos += props_size;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/index.c xz-5.0.5/src/liblzma/common/index.c
--- xz-5.0.5.orig/src/liblzma/common/index.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/index.c	2016-08-25 13:59:23.786734700 +0300
@@ -398,10 +398,11 @@
 lzma_index_init(lzma_allocator *allocator)
 {
 	lzma_index *i = index_init_plain(allocator);
+	index_stream *s;
 	if (i == NULL)
 		return NULL;
 
-	index_stream *s = index_stream_init(0, 0, 1, 0, allocator);
+	s = index_stream_init(0, 0, 1, 0, allocator);
 	if (s == NULL) {
 		lzma_free(i, allocator);
 		return NULL;
@@ -617,11 +618,12 @@
 extern LZMA_API(lzma_ret)
 lzma_index_stream_padding(lzma_index *i, lzma_vli stream_padding)
 {
+    index_stream *s;
 	if (i == NULL || stream_padding > LZMA_VLI_MAX
 			|| (stream_padding & 3) != 0)
 		return LZMA_PROG_ERROR;
 
-	index_stream *s = (index_stream *)(i->streams.rightmost);
+	s = (index_stream *)(i->streams.rightmost);
 
 	// Check that the new value won't make the file grow too big.
 	const lzma_vli old_stream_padding = s->stream_padding;
@@ -640,14 +642,16 @@
 lzma_index_append(lzma_index *i, lzma_allocator *allocator,
 		lzma_vli unpadded_size, lzma_vli uncompressed_size)
 {
+    index_stream *s;
+    index_group *g;
 	// Validate.
 	if (i == NULL || unpadded_size < UNPADDED_SIZE_MIN
 			|| unpadded_size > UNPADDED_SIZE_MAX
 			|| uncompressed_size > LZMA_VLI_MAX)
 		return LZMA_PROG_ERROR;
 
-	index_stream *s = (index_stream *)(i->streams.rightmost);
-	index_group *g = (index_group *)(s->groups.rightmost);
+	s = (index_stream *)(i->streams.rightmost);
+	g = (index_group *)(s->groups.rightmost);
 
 	const lzma_vli compressed_base = g == NULL ? 0
 			: vli_ceil4(g->records[g->last].unpadded_sum);
@@ -861,12 +865,15 @@
 static index_stream *
 index_dup_stream(const index_stream *src, lzma_allocator *allocator)
 {
+	index_stream *dest;
+	index_group *destg;
+
 	// Catch a somewhat theoretical integer overflow.
 	if (src->record_count > PREALLOC_MAX)
 		return NULL;
 
 	// Allocate and initialize a new Stream.
-	index_stream *dest = index_stream_init(src->node.compressed_base,
+	dest = index_stream_init(src->node.compressed_base,
 			src->node.uncompressed_base, src->number,
 			src->block_number_base, allocator);
 
@@ -884,7 +891,7 @@
 	// Allocate memory for the Records. We put all the Records into
 	// a single group. It's simplest and also tends to make
 	// lzma_index_locate() a little bit faster with very big Indexes.
-	index_group *destg = lzma_alloc(sizeof(index_group)
+	destg = lzma_alloc(sizeof(index_group)
 			+ src->record_count * sizeof(index_record),
 			allocator);
 	if (destg == NULL) {
@@ -1096,14 +1103,19 @@
 extern LZMA_API(lzma_bool)
 lzma_index_iter_next(lzma_index_iter *iter, lzma_index_iter_mode mode)
 {
+	const lzma_index *i;
+	const index_stream *stream;
+	const index_group *group;
+	size_t record;
+
 	// Catch unsupported mode values.
 	if ((unsigned int)(mode) > LZMA_INDEX_ITER_NONEMPTY_BLOCK)
 		return true;
 
-	const lzma_index *i = iter->internal[ITER_INDEX].p;
-	const index_stream *stream = iter->internal[ITER_STREAM].p;
-	const index_group *group = NULL;
-	size_t record = iter->internal[ITER_RECORD].s;
+	i = iter->internal[ITER_INDEX].p;
+	stream = iter->internal[ITER_STREAM].p;
+	group = NULL;
+	record = iter->internal[ITER_RECORD].s;
 
 	// If we are being asked for the next Stream, leave group to NULL
 	// so that the rest of the this function thinks that this Stream
@@ -1204,18 +1216,19 @@
 lzma_index_iter_locate(lzma_index_iter *iter, lzma_vli target)
 {
 	const lzma_index *i = iter->internal[ITER_INDEX].p;
-
+	const index_stream *stream;
+	const index_group *group;
 	// If the target is past the end of the file, return immediately.
 	if (i->uncompressed_size <= target)
 		return true;
 
 	// Locate the Stream containing the target offset.
-	const index_stream *stream = index_tree_locate(&i->streams, target);
+	stream = index_tree_locate(&i->streams, target);
 	assert(stream != NULL);
 	target -= stream->node.uncompressed_base;
 
 	// Locate the group containing the target offset.
-	const index_group *group = index_tree_locate(&stream->groups, target);
+	group = index_tree_locate(&stream->groups, target);
 	assert(group != NULL);
 
 	// Use binary search to locate the exact Record. It is the first
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/index_decoder.c xz-5.0.5/src/liblzma/common/index_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/index_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/index_decoder.c	2016-08-25 13:59:23.787711400 +0300
@@ -303,13 +303,15 @@
 		lzma_index **i, uint64_t *memlimit, lzma_allocator *allocator,
 		const uint8_t *in, size_t *in_pos, size_t in_size)
 {
+        lzma_coder coder;
+
 	// Sanity checks
 	if (i == NULL || memlimit == NULL
 			|| in == NULL || in_pos == NULL || *in_pos > in_size)
 		return LZMA_PROG_ERROR;
 
 	// Initialize the decoder.
-	lzma_coder coder;
+	
 	return_if_error(index_decoder_reset(&coder, allocator, i, *memlimit));
 
 	// Store the input start position so that we can restore it in case
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/index_encoder.c xz-5.0.5/src/liblzma/common/index_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/index_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/index_encoder.c	2016-08-25 13:59:23.787711400 +0300
@@ -220,6 +220,10 @@
 lzma_index_buffer_encode(const lzma_index *i,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 {
+
+        lzma_coder coder;
+	size_t out_start;
+	lzma_ret ret;
 	// Validate the arguments.
 	if (i == NULL || out == NULL || out_pos == NULL || *out_pos > out_size)
 		return LZMA_PROG_ERROR;
@@ -230,13 +234,12 @@
 
 	// The Index encoder needs just one small data structure so we can
 	// allocate it on stack.
-	lzma_coder coder;
 	index_encoder_reset(&coder, i);
 
 	// Do the actual encoding. This should never fail, but store
 	// the original *out_pos just in case.
-	const size_t out_start = *out_pos;
-	lzma_ret ret = index_encode(&coder, NULL, NULL, NULL, 0,
+	out_start = *out_pos;
+	ret = index_encode(&coder, NULL, NULL, NULL, 0,
 			out, out_pos, out_size, LZMA_RUN);
 
 	if (ret == LZMA_STREAM_END) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/index_hash.c xz-5.0.5/src/liblzma/common/index_hash.c
--- xz-5.0.5.orig/src/liblzma/common/index_hash.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/index_hash.c	2016-08-25 13:59:23.788688300 +0300
@@ -173,6 +173,9 @@
 lzma_index_hash_decode(lzma_index_hash *index_hash, const uint8_t *in,
 		size_t *in_pos, size_t in_size)
 {
+
+    size_t in_start;
+    lzma_ret ret;
 	// Catch zero input buffer here, because in contrast to Index encoder
 	// and decoder functions, applications call this function directly
 	// instead of via lzma_code(), which does the buffer checking.
@@ -182,8 +185,8 @@
 	// NOTE: This function has many similarities to index_encode() and
 	// index_decode() functions found from index_encoder.c and
 	// index_decoder.c. See the comments especially in index_encoder.c.
-	const size_t in_start = *in_pos;
-	lzma_ret ret = LZMA_OK;
+	in_start = *in_pos;
+	ret = LZMA_OK;
 
 	while (*in_pos < in_size)
 	switch (index_hash->sequence) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_buffer_decoder.c xz-5.0.5/src/liblzma/common/stream_buffer_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_buffer_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_buffer_decoder.c	2016-08-25 13:59:23.789665600 +0300
@@ -19,6 +19,10 @@
 		const uint8_t *in, size_t *in_pos, size_t in_size,
 		uint8_t *out, size_t *out_pos, size_t out_size)
 {
+
+    lzma_next_coder stream_decoder = LZMA_NEXT_CODER_INIT;
+    lzma_ret ret;
+
 	// Sanity checks
 	if (in_pos == NULL || (in == NULL && *in_pos != in_size)
 			|| *in_pos > in_size || out_pos == NULL
@@ -33,8 +37,7 @@
 	// Initialize the Stream decoder.
 	// TODO: We need something to tell the decoder that it can use the
 	// output buffer as workspace, and thus save significant amount of RAM.
-	lzma_next_coder stream_decoder = LZMA_NEXT_CODER_INIT;
-	lzma_ret ret = lzma_stream_decoder_init(
+	ret = lzma_stream_decoder_init(
 			&stream_decoder, allocator, *memlimit, flags);
 
 	if (ret == LZMA_OK) {
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_buffer_encoder.c xz-5.0.5/src/liblzma/common/stream_buffer_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_buffer_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_buffer_encoder.c	2016-08-25 13:59:23.789665600 +0300
@@ -45,6 +45,7 @@
 		lzma_allocator *allocator, const uint8_t *in, size_t in_size,
 		uint8_t *out, size_t *out_pos_ptr, size_t out_size)
 {
+    size_t out_pos;
 	// Sanity checks
 	if (filters == NULL || (unsigned int)(check) > LZMA_CHECK_ID_MAX
 			|| (in == NULL && in_size != 0) || out == NULL
@@ -61,7 +62,7 @@
 
 	// Use a local copy. We update *out_pos_ptr only if everything
 	// succeeds.
-	size_t out_pos = *out_pos_ptr;
+	out_pos = *out_pos_ptr;
 
 	// Check that there's enough space for both Stream Header and
 	// Stream Footer.
@@ -97,6 +98,8 @@
 
 	// Index
 	{
+
+	    lzma_ret ret;
 		// Create an Index. It will have one Record if there was
 		// at least one byte of input to encode. Otherwise the
 		// Index will be empty.
@@ -104,7 +107,7 @@
 		if (i == NULL)
 			return LZMA_MEM_ERROR;
 
-		lzma_ret ret = LZMA_OK;
+		ret = LZMA_OK;
 
 		if (in_size > 0)
 			ret = lzma_index_append(i, allocator,
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_decoder.c xz-5.0.5/src/liblzma/common/stream_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_decoder.c	2016-08-25 13:59:23.790642200 +0300
@@ -260,6 +260,7 @@
 	}
 
 	case SEQ_INDEX: {
+	    lzma_ret ret;
 		// If we don't have any input, don't call
 		// lzma_index_hash_decode() since it would return
 		// LZMA_BUF_ERROR, which we must not do here.
@@ -268,7 +269,7 @@
 
 		// Decode the Index and compare it to the hash calculated
 		// from the sizes of the Blocks (if any).
-		const lzma_ret ret = lzma_index_hash_decode(coder->index_hash,
+		ret = lzma_index_hash_decode(coder->index_hash,
 				in, in_pos, in_size);
 		if (ret != LZMA_STREAM_END)
 			return ret;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_encoder.c xz-5.0.5/src/liblzma/common/stream_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_encoder.c	2016-08-25 13:59:23.791619200 +0300
@@ -147,6 +147,7 @@
 	}
 
 	case SEQ_BLOCK_ENCODE: {
+		lzma_vli unpadded_size;
 		static const lzma_action convert[4] = {
 			LZMA_RUN,
 			LZMA_SYNC_FLUSH,
@@ -162,7 +163,7 @@
 			return ret;
 
 		// Add a new Index Record.
-		const lzma_vli unpadded_size = lzma_block_unpadded_size(
+		unpadded_size = lzma_block_unpadded_size(
 				&coder->block_options);
 		assert(unpadded_size != 0);
 		return_if_error(lzma_index_append(coder->index, allocator,
@@ -174,6 +175,12 @@
 	}
 
 	case SEQ_INDEX_ENCODE: {
+	    const lzma_stream_flags stream_flags = {
+		.version = 0,
+		.backward_size = lzma_index_size(coder->index),
+		.check = coder->block_options.check,
+	    };
+
 		// Call the Index encoder. It doesn't take any input, so
 		// those pointers can be NULL.
 		const lzma_ret ret = coder->index_encoder.code(
@@ -184,11 +191,6 @@
 			return ret;
 
 		// Encode the Stream Footer into coder->buffer.
-		const lzma_stream_flags stream_flags = {
-			.version = 0,
-			.backward_size = lzma_index_size(coder->index),
-			.check = coder->block_options.check,
-		};
 
 		if (lzma_stream_footer_encode(&stream_flags, coder->buffer)
 				!= LZMA_OK)
@@ -268,6 +270,12 @@
 {
 	lzma_next_coder_init(&lzma_stream_encoder_init, next, allocator);
 
+	// Encode the Stream Header
+	lzma_stream_flags stream_flags = {
+	    .version = 0,
+	    .check = check,
+	};
+
 	if (filters == NULL)
 		return LZMA_PROG_ERROR;
 
@@ -297,11 +305,6 @@
 	if (next->coder->index == NULL)
 		return LZMA_MEM_ERROR;
 
-	// Encode the Stream Header
-	lzma_stream_flags stream_flags = {
-		.version = 0,
-		.check = check,
-	};
 	return_if_error(lzma_stream_header_encode(
 			&stream_flags, next->coder->buffer));
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_flags_decoder.c xz-5.0.5/src/liblzma/common/stream_flags_decoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_flags_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_flags_decoder.c	2016-08-25 13:59:23.792595300 +0300
@@ -30,13 +30,14 @@
 extern LZMA_API(lzma_ret)
 lzma_stream_header_decode(lzma_stream_flags *options, const uint8_t *in)
 {
+	uint32_t crc;
 	// Magic
 	if (memcmp(in, lzma_header_magic, sizeof(lzma_header_magic)) != 0)
 		return LZMA_FORMAT_ERROR;
 
 	// Verify the CRC32 so we can distinguish between corrupt
 	// and unsupported files.
-	const uint32_t crc = lzma_crc32(in + sizeof(lzma_header_magic),
+	crc = lzma_crc32(in + sizeof(lzma_header_magic),
 			LZMA_STREAM_FLAGS_SIZE, 0);
 	if (crc != unaligned_read32le(in + sizeof(lzma_header_magic)
 			+ LZMA_STREAM_FLAGS_SIZE))
@@ -59,13 +60,15 @@
 extern LZMA_API(lzma_ret)
 lzma_stream_footer_decode(lzma_stream_flags *options, const uint8_t *in)
 {
+    uint32_t crc;
+
 	// Magic
 	if (memcmp(in + sizeof(uint32_t) * 2 + LZMA_STREAM_FLAGS_SIZE,
 			lzma_footer_magic, sizeof(lzma_footer_magic)) != 0)
 		return LZMA_FORMAT_ERROR;
 
 	// CRC32
-	const uint32_t crc = lzma_crc32(in + sizeof(uint32_t),
+	crc = lzma_crc32(in + sizeof(uint32_t),
 			sizeof(uint32_t) + LZMA_STREAM_FLAGS_SIZE, 0);
 	if (crc != unaligned_read32le(in))
 		return LZMA_DATA_ERROR;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/stream_flags_encoder.c xz-5.0.5/src/liblzma/common/stream_flags_encoder.c
--- xz-5.0.5.orig/src/liblzma/common/stream_flags_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/stream_flags_encoder.c	2016-08-25 13:59:23.792595300 +0300
@@ -29,6 +29,7 @@
 extern LZMA_API(lzma_ret)
 lzma_stream_header_encode(const lzma_stream_flags *options, uint8_t *out)
 {
+    uint32_t crc;
 	assert(sizeof(lzma_header_magic) + LZMA_STREAM_FLAGS_SIZE
 			+ 4 == LZMA_STREAM_HEADER_SIZE);
 
@@ -43,7 +44,7 @@
 		return LZMA_PROG_ERROR;
 
 	// CRC32 of the Stream Header
-	const uint32_t crc = lzma_crc32(out + sizeof(lzma_header_magic),
+	crc = lzma_crc32(out + sizeof(lzma_header_magic),
 			LZMA_STREAM_FLAGS_SIZE, 0);
 
 	unaligned_write32le(out + sizeof(lzma_header_magic)
@@ -56,6 +57,7 @@
 extern LZMA_API(lzma_ret)
 lzma_stream_footer_encode(const lzma_stream_flags *options, uint8_t *out)
 {
+    uint32_t crc;
 	assert(2 * 4 + LZMA_STREAM_FLAGS_SIZE + sizeof(lzma_footer_magic)
 			== LZMA_STREAM_HEADER_SIZE);
 
@@ -73,7 +75,7 @@
 		return LZMA_PROG_ERROR;
 
 	// CRC32
-	const uint32_t crc = lzma_crc32(
+	crc = lzma_crc32(
 			out + 4, 4 + LZMA_STREAM_FLAGS_SIZE, 0);
 
 	unaligned_write32le(out, crc);
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/common/vli_size.c xz-5.0.5/src/liblzma/common/vli_size.c
--- xz-5.0.5.orig/src/liblzma/common/vli_size.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/common/vli_size.c	2016-08-25 13:59:23.793573400 +0300
@@ -16,10 +16,11 @@
 extern LZMA_API(uint32_t)
 lzma_vli_size(lzma_vli vli)
 {
+    uint32_t i = 0;
+
 	if (vli > LZMA_VLI_MAX)
 		return 0;
 
-	uint32_t i = 0;
 	do {
 		vli >>= 7;
 		++i;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/delta/delta_common.c xz-5.0.5/src/liblzma/delta/delta_common.c
--- xz-5.0.5.orig/src/liblzma/delta/delta_common.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/delta/delta_common.c	2016-08-25 13:59:23.794550700 +0300
@@ -27,6 +27,7 @@
 lzma_delta_coder_init(lzma_next_coder *next, lzma_allocator *allocator,
 		const lzma_filter_info *filters)
 {
+    const lzma_options_delta *opt;
 	// Allocate memory for the decoder if needed.
 	if (next->coder == NULL) {
 		next->coder = lzma_alloc(sizeof(lzma_coder), allocator);
@@ -43,7 +44,7 @@
 		return LZMA_OPTIONS_ERROR;
 
 	// Set the delta distance.
-	const lzma_options_delta *opt = filters[0].options;
+	opt = filters[0].options;
 	next->coder->distance = opt->dist;
 
 	// Initialize the rest of the variables.
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/delta/delta_decoder.c xz-5.0.5/src/liblzma/delta/delta_decoder.c
--- xz-5.0.5.orig/src/liblzma/delta/delta_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/delta/delta_decoder.c	2016-08-25 13:59:23.794550700 +0300
@@ -59,11 +59,11 @@
 lzma_delta_props_decode(void **options, lzma_allocator *allocator,
 		const uint8_t *props, size_t props_size)
 {
+    lzma_options_delta *opt;
 	if (props_size != 1)
 		return LZMA_OPTIONS_ERROR;
 
-	lzma_options_delta *opt
-			= lzma_alloc(sizeof(lzma_options_delta), allocator);
+	opt = lzma_alloc(sizeof(lzma_options_delta), allocator);
 	if (opt == NULL)
 		return LZMA_MEM_ERROR;
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/delta/delta_encoder.c xz-5.0.5/src/liblzma/delta/delta_encoder.c
--- xz-5.0.5.orig/src/liblzma/delta/delta_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/delta/delta_encoder.c	2016-08-25 13:59:23.795527900 +0300
@@ -109,12 +109,13 @@
 extern lzma_ret
 lzma_delta_props_encode(const void *options, uint8_t *out)
 {
+    const lzma_options_delta *opt = options;
+
 	// The caller must have already validated the options, so it's
 	// LZMA_PROG_ERROR if they are invalid.
 	if (lzma_delta_coder_memusage(options) == UINT64_MAX)
 		return LZMA_PROG_ERROR;
 
-	const lzma_options_delta *opt = options;
 	out[0] = opt->dist - LZMA_DELTA_DIST_MIN;
 
 	return LZMA_OK;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lz/lz_decoder.c xz-5.0.5/src/liblzma/lz/lz_decoder.c
--- xz-5.0.5.orig/src/liblzma/lz/lz_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lz/lz_decoder.c	2016-08-25 13:59:23.796504900 +0300
@@ -69,13 +69,16 @@
 		size_t *restrict out_pos, size_t out_size)
 {
 	while (true) {
+	    size_t copy_size;
+	    lzma_ret ret;
+	    size_t dict_start;
 		// Wrap the dictionary if needed.
 		if (coder->dict.pos == coder->dict.size)
 			coder->dict.pos = 0;
 
 		// Store the current dictionary position. It is needed to know
 		// where to start copying to the out[] buffer.
-		const size_t dict_start = coder->dict.pos;
+		dict_start = coder->dict.pos;
 
 		// Calculate how much we allow coder->lz.code() to decode.
 		// It must not decode past the end of the dictionary
@@ -86,13 +89,13 @@
 					coder->dict.size - coder->dict.pos);
 
 		// Call the coder->lz.code() to do the actual decoding.
-		const lzma_ret ret = coder->lz.code(
+		ret = coder->lz.code(
 				coder->lz.coder, &coder->dict,
 				in, in_pos, in_size);
 
 		// Copy the decoded data from the dictionary to the out[]
 		// buffer.
-		const size_t copy_size = coder->dict.pos - dict_start;
+		copy_size = coder->dict.pos - dict_start;
 		assert(copy_size <= out_size - *out_pos);
 		memcpy(out + *out_pos, coder->dict.buf + dict_start,
 				copy_size);
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lz/lz_encoder.c xz-5.0.5/src/liblzma/lz/lz_encoder.c
--- xz-5.0.5.orig/src/liblzma/lz/lz_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lz/lz_encoder.c	2016-08-25 13:59:23.797481800 +0300
@@ -80,6 +80,8 @@
 		size_t *in_pos, size_t in_size, lzma_action action)
 {
 	assert(coder->mf.read_pos <= coder->mf.write_pos);
+	size_t write_pos = coder->mf.write_pos;
+	lzma_ret ret;
 
 	// Move the sliding window if needed.
 	if (coder->mf.read_pos >= coder->mf.size - coder->mf.keep_size_after)
@@ -88,8 +90,7 @@
 	// Maybe this is ugly, but lzma_mf uses uint32_t for most things
 	// (which I find cleanest), but we need size_t here when filling
 	// the history window.
-	size_t write_pos = coder->mf.write_pos;
-	lzma_ret ret;
+
 	if (coder->next.code == NULL) {
 		// Not using a filter, simply memcpy() as much as possible.
 		lzma_bufcpy(in, in_pos, in_size, coder->mf.buffer,
@@ -182,6 +183,8 @@
 lz_encoder_prepare(lzma_mf *mf, lzma_allocator *allocator,
 		const lzma_lz_options *lz_options)
 {
+    uint32_t new_count;
+    bool is_bt;
 	// For now, the dictionary size is limited to 1.5 GiB. This may grow
 	// in the future if needed, but it needs a little more work than just
 	// changing this check.
@@ -288,7 +291,7 @@
 	if (hash_bytes > mf->nice_len)
 		return true;
 
-	const bool is_bt = (lz_options->match_finder & 0x10) != 0;
+	is_bt = (lz_options->match_finder & 0x10) != 0;
 	uint32_t hs;
 
 	if (hash_bytes == 2) {
@@ -337,7 +340,7 @@
 	if (is_bt)
 		mf->sons_count *= 2;
 
-	const uint32_t new_count = mf->hash_size_sum + mf->sons_count;
+	new_count = mf->hash_size_sum + mf->sons_count;
 
 	// Deallocate the old hash array if it exists and has different size
 	// than what is needed now.
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lz/lz_encoder_mf.c xz-5.0.5/src/liblzma/lz/lz_encoder_mf.c
--- xz-5.0.5.orig/src/liblzma/lz/lz_encoder_mf.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lz/lz_encoder_mf.c	2016-08-25 13:59:23.798458500 +0300
@@ -54,16 +54,18 @@
 			// encoder or the number of bytes left in the
 			// dictionary, whichever is smaller.
 			uint32_t limit = mf_avail(mf) + 1;
+			uint8_t *p1;
+			uint8_t *p2;
 			if (limit > mf->match_len_max)
 				limit = mf->match_len_max;
 
 			// Pointer to the byte we just ran through
 			// the match finder.
-			const uint8_t *p1 = mf_ptr(mf) - 1;
+			p1 = mf_ptr(mf) - 1;
 
 			// Pointer to the beginning of the match. We need -1
 			// here because the match distances are zero based.
-			const uint8_t *p2 = p1 - matches[count - 1].dist - 1;
+			p2 = p1 - matches[count - 1].dist - 1;
 
 			while (len_best < limit
 					&& p1[len_best] == p2[len_best])
@@ -261,10 +263,11 @@
 
 	while (true) {
 		const uint32_t delta = pos - cur_match;
+		const uint8_t *pb;
 		if (depth-- == 0 || delta >= cyclic_size)
 			return matches;
 
-		const uint8_t *const pb = cur - delta;
+		pb = cur - delta;
 		cur_match = son[cyclic_pos - delta
 				+ (delta > cyclic_pos ? cyclic_size : 0)];
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/fastpos.h xz-5.0.5/src/liblzma/lzma/fastpos.h
--- xz-5.0.5.orig/src/liblzma/lzma/fastpos.h	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/fastpos.h	2016-08-25 13:59:23.799435200 +0300
@@ -75,6 +75,8 @@
 // on all systems I have tried. The size optimized version is sometimes
 // slightly faster, but sometimes it is a lot slower.
 
+#include "config.h"
+
 #ifdef HAVE_SMALL
 #	define get_pos_slot(pos) ((pos) <= 4 ? (pos) : get_pos_slot_2(pos))
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma_decoder.c xz-5.0.5/src/liblzma/lzma/lzma_decoder.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma_decoder.c	2016-08-25 13:59:23.800412400 +0300
@@ -285,6 +285,7 @@
 		const uint8_t *restrict in,
 		size_t *restrict in_pos, size_t in_size)
 {
+    lzma_dict dict;
 	////////////////////
 	// Initialization //
 	////////////////////
@@ -299,7 +300,7 @@
 	// Making local copies of often-used variables improves both
 	// speed and readability.
 
-	lzma_dict dict = *dictptr;
+	dict = *dictptr;
 
 	const size_t dict_start = dict.pos;
 
@@ -1028,11 +1029,12 @@
 lzma_lzma_props_decode(void **options, lzma_allocator *allocator,
 		const uint8_t *props, size_t props_size)
 {
+    lzma_options_lzma *opt;
 	if (props_size != 5)
 		return LZMA_OPTIONS_ERROR;
 
-	lzma_options_lzma *opt
-			= lzma_alloc(sizeof(lzma_options_lzma), allocator);
+	
+	opt = lzma_alloc(sizeof(lzma_options_lzma), allocator);
 	if (opt == NULL)
 		return LZMA_MEM_ERROR;
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder.c xz-5.0.5/src/liblzma/lzma/lzma_encoder.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma_encoder.c	2016-08-25 13:59:23.800412400 +0300
@@ -313,12 +313,13 @@
 		uint8_t *restrict out, size_t *restrict out_pos,
 		size_t out_size, uint32_t limit)
 {
+    uint32_t position;
 	// Initialize the stream if no data has been encoded yet.
 	if (!coder->is_initialized && !encode_init(coder, mf))
 		return LZMA_OK;
 
 	// Get the lowest bits of the uncompressed offset from the LZ layer.
-	uint32_t position = mf_position(mf);
+	position = mf_position(mf);
 
 	while (true) {
 		// Encode pending bits, if any. Calling this before encoding
@@ -625,13 +626,14 @@
 extern uint64_t
 lzma_lzma_encoder_memusage(const void *options)
 {
+    lzma_lz_options lz_options;
+    uint64_t lz_memusage;
 	if (!is_options_valid(options))
 		return UINT64_MAX;
 
-	lzma_lz_options lz_options;
 	set_lz_options(&lz_options, options);
 
-	const uint64_t lz_memusage = lzma_lz_encoder_memusage(&lz_options);
+	lz_memusage = lzma_lz_encoder_memusage(&lz_options);
 	if (lz_memusage == UINT64_MAX)
 		return UINT64_MAX;
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder_optimum_normal.c xz-5.0.5/src/liblzma/lzma/lzma_encoder_optimum_normal.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder_optimum_normal.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma_encoder_optimum_normal.c	2016-08-25 13:59:23.801389400 +0300
@@ -456,6 +456,7 @@
 	uint32_t new_len = coder->longest_match_length;
 	uint32_t pos_prev = coder->opts[cur].pos_prev;
 	lzma_lzma_state state;
+        uint32_t buf_avail;
 
 	if (coder->opts[cur].prev_1_is_literal) {
 		--pos_prev;
@@ -565,7 +566,7 @@
 	if (buf_avail_full < 2)
 		return len_end;
 
-	const uint32_t buf_avail = my_min(buf_avail_full, nice_len);
+	buf_avail = my_min(buf_avail_full, nice_len);
 
 	if (!next_is_literal && match_byte != current_byte) { // speed optimization
 		// try literal + rep0
@@ -612,6 +613,8 @@
 	uint32_t start_len = 2; // speed optimization
 
 	for (uint32_t rep_index = 0; rep_index < REP_DISTANCES; ++rep_index) {
+	    uint32_t len_test_2;
+	    uint32_t limit;
 		const uint8_t *const buf_back = buf - reps[rep_index] - 1;
 		if (not_equal_16(buf, buf_back))
 			continue;
@@ -647,8 +650,8 @@
 			start_len = len_test + 1;
 
 
-		uint32_t len_test_2 = len_test + 1;
-		const uint32_t limit = my_min(buf_avail_full,
+		len_test_2 = len_test + 1;
+		limit = my_min(buf_avail_full,
 				len_test_2 + nice_len);
 		for (; len_test_2 < limit
 				&& buf[len_test_2] == buf_back[len_test_2];
@@ -815,6 +818,10 @@
 		uint32_t *restrict back_res, uint32_t *restrict len_res,
 		uint32_t position)
 {
+    uint32_t reps[REP_DISTANCES];
+    uint32_t len_end;
+    uint32_t cur;
+
 	// If we have symbols pending, return the next pending symbol.
 	if (coder->opts_end_index != coder->opts_current_index) {
 		assert(mf->read_ahead > 0);
@@ -841,14 +848,13 @@
 	// the original function into two pieces makes it at least a little
 	// more readable, since those two parts don't share many variables.
 
-	uint32_t len_end = helper1(coder, mf, back_res, len_res, position);
+	len_end = helper1(coder, mf, back_res, len_res, position);
 	if (len_end == UINT32_MAX)
 		return;
 
-	uint32_t reps[REP_DISTANCES];
+
 	memcpy(reps, coder->reps, sizeof(reps));
 
-	uint32_t cur;
 	for (cur = 1; cur < len_end; ++cur) {
 		assert(cur < OPTS);
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder_presets.c xz-5.0.5/src/liblzma/lzma/lzma_encoder_presets.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma_encoder_presets.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma_encoder_presets.c	2016-08-25 13:59:23.802366300 +0300
@@ -30,14 +30,15 @@
 	options->lp = LZMA_LP_DEFAULT;
 	options->pb = LZMA_PB_DEFAULT;
 
-	options->dict_size = UINT32_C(1) << (uint8_t []){
-			18, 20, 21, 22, 22, 23, 23, 24, 25, 26 }[level];
+        static const uint8_t dict_size_values[] = { 18, 20, 21, 22, 22, 23, 23, 24, 25, 26 };
+        options->dict_size = UINT32_C(1) << dict_size_values[level];
 
 	if (level <= 3) {
 		options->mode = LZMA_MODE_FAST;
 		options->mf = level == 0 ? LZMA_MF_HC3 : LZMA_MF_HC4;
 		options->nice_len = level <= 1 ? 128 : 273;
-		options->depth = (uint8_t []){ 4, 8, 24, 48 }[level];
+                static const uint8_t depth_values[] = { 4, 8, 24, 48 };
+                options->depth = depth_values[level];
 	} else {
 		options->mode = LZMA_MODE_NORMAL;
 		options->mf = LZMA_MF_BT4;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma2_decoder.c xz-5.0.5/src/liblzma/lzma/lzma2_decoder.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma2_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma2_decoder.c	2016-08-25 13:59:23.803343300 +0300
@@ -272,6 +272,8 @@
 lzma_lzma2_props_decode(void **options, lzma_allocator *allocator,
 		const uint8_t *props, size_t props_size)
 {
+	lzma_options_lzma *opt;
+
 	if (props_size != 1)
 		return LZMA_OPTIONS_ERROR;
 
@@ -283,8 +285,7 @@
 	if (props[0] > 40)
 		return LZMA_OPTIONS_ERROR;
 
-	lzma_options_lzma *opt = lzma_alloc(
-			sizeof(lzma_options_lzma), allocator);
+	opt = lzma_alloc(sizeof(lzma_options_lzma), allocator);
 	if (opt == NULL)
 		return LZMA_MEM_ERROR;
 
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/lzma/lzma2_encoder.c xz-5.0.5/src/liblzma/lzma/lzma2_encoder.c
--- xz-5.0.5.orig/src/liblzma/lzma/lzma2_encoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/lzma/lzma2_encoder.c	2016-08-25 13:59:23.804319700 +0300
@@ -273,6 +273,7 @@
 static lzma_ret
 lzma2_encoder_options_update(lzma_coder *coder, const lzma_filter *filter)
 {
+    lzma_options_lzma *opt;
 	// New options can be set only when there is no incomplete chunk.
 	// This is the case at the beginning of the raw stream and right
 	// after LZMA_SYNC_FLUSH.
@@ -281,7 +282,7 @@
 
 	// Look if there are new options. At least for now,
 	// only lc/lp/pb can be changed.
-	const lzma_options_lzma *opt = filter->options;
+	opt = filter->options;
 	if (coder->opt_cur.lc != opt->lc || coder->opt_cur.lp != opt->lp
 			|| coder->opt_cur.pb != opt->pb) {
 		// Validate the options.
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/simple/simple_decoder.c xz-5.0.5/src/liblzma/simple/simple_decoder.c
--- xz-5.0.5.orig/src/liblzma/simple/simple_decoder.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/simple/simple_decoder.c	2016-08-25 13:59:23.804319700 +0300
@@ -17,13 +17,14 @@
 lzma_simple_props_decode(void **options, lzma_allocator *allocator,
 		const uint8_t *props, size_t props_size)
 {
+    lzma_options_bcj *opt;
 	if (props_size == 0)
 		return LZMA_OK;
 
 	if (props_size != 4)
 		return LZMA_OPTIONS_ERROR;
 
-	lzma_options_bcj *opt = lzma_alloc(
+	opt = lzma_alloc(
 			sizeof(lzma_options_bcj), allocator);
 	if (opt == NULL)
 		return LZMA_MEM_ERROR;
diff -Nrub -x '*~' -x '*\.rej' -x '*\.orig' -x'*\.o' xz-5.0.5.orig/src/liblzma/simple/x86.c xz-5.0.5/src/liblzma/simple/x86.c
--- xz-5.0.5.orig/src/liblzma/simple/x86.c	2013-06-30 15:49:46.000000000 +0300
+++ xz-5.0.5/src/liblzma/simple/x86.c	2016-08-25 13:59:23.805297200 +0300
@@ -36,23 +36,27 @@
 	uint32_t prev_mask = simple->prev_mask;
 	uint32_t prev_pos = simple->prev_pos;
 
+	size_t limit;
+	size_t buffer_pos;
+
 	if (size < 5)
 		return 0;
 
 	if (now_pos - prev_pos > 5)
 		prev_pos = now_pos - 5;
 
-	const size_t limit = size - 5;
-	size_t buffer_pos = 0;
+	limit = size - 5;
+	buffer_pos = 0;
 
 	while (buffer_pos <= limit) {
 		uint8_t b = buffer[buffer_pos];
+		uint32_t offset;
 		if (b != 0xE8 && b != 0xE9) {
 			++buffer_pos;
 			continue;
 		}
 
-		const uint32_t offset = now_pos + (uint32_t)(buffer_pos)
+		offset = now_pos + (uint32_t)(buffer_pos)
 				- prev_pos;
 		prev_pos = now_pos + (uint32_t)(buffer_pos);
 
